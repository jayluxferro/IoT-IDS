# File from polymorph project
# Copyright (C) 2018 Santiago Hernandez Ramos <shramos@protonmail.com>
# For more information about the project: https://github.com/shramos/polymorph

from polymorph.value import Value
from collections import OrderedDict
from termcolor import colored


class TField(object):
    """This class represents a field in a `Template`."""

    def __init__(self, name, value, tslice, custom, size,
                 raw, frepr="", layer=None, ftype=None):
        """Initialization method for the `TField` class.

        Parameters
        ----------
        name : :obj:`str`
            The name of the `TField`.
        value : :obj:`bytes`
            The value of the `TField` encoded in bytes.
        tslice : :obj:`str`
            :obj:`slice` encoded in hexadecimal representing the position
            of the `TField` in the raw packet data.
        custom : bool
            True if the `TField` has been modified or generated by a user or
            the tool, False otherwise.
        size : int
            Size of the `TField` in bytes.
        raw : :obj:`str`
            Package content bytes encoded in hexadecimal.
        frepr : str, optional
            Custom representation of `TField` to be showed in the interface.
        layer : :obj:`TLayer`, optional
            Parent layer.
        frepr : :obj:`str`, optional
            Type of the `TField` represented as a tuple.

        """
        self._name = name.lower()
        self._value = Value(value, ftype)
        self._frepr = frepr
        self._ftype = self._value.type()
        self._slice = tslice
        self._custom = custom
        self._size = size
        self._ref_value = None
        self._layer = layer
        self._raw = raw

    def __repr__(self):
        return "<tfield.TField: %s>" % self._name

    def __len__(self):
        return self._size

    def is_int(self):
        """Check if the `TField` is of type `int` or `long`.

        Returns
        -------
        bool
            True if it is of type `int` or `long`, False otherwise.

        """
        return self._ftype[0] is int

    def is_str(self):
        """Check if the `TField` is of type `str`.

        Returns
        -------
        bool
            True if it is of type `str`, False otherwise.

        """
        return self._ftype[0] is str

    def order(self):
        """Returns the order of the field if it is int.

        Returns
        -------
        :obj:`str`
            The order of the field if int (big or little)
        
        """
        if self.is_int():
            return self._ftype[1]
        return None

    def to_int(self, order='big'):
        """Sets the type of the `TField` to `int`."""
        self._value.to_int(order)
        self._ftype = self._value.type()

    def to_str(self):
        """Sets the type of the `TField` to `str`."""
        self._value.to_str()
        self._ftype = self._value.type()

    def to_hex(self):
        """Sets the type of the `TField` to hex."""
        self._value.to_hex()
        self._ftype = self._value.type()

    def to_bytes(self):
        """Sets the type of the `TField` to `bytes`."""
        self._value.to_bytes()
        self._ftype = self._value.type()

    @property
    def name(self):
        """str: Name of the `TField` in `str` and lowercase."""
        return self._name

    @name.setter
    def name(self, value):
        self._name = value.lower()

    @property
    def frepr(self):
        return self._frepr

    @frepr.setter
    def frepr(self, value):
        self._frepr = str(value)

    @property
    def value(self):
        """str, int: Returns the value of the `TField`, values can be:
        A custom representation of the field, integer or string."""
        return self._value.value

    @value.setter
    def value(self, value):
        self._value = self.create_value(value)
        # Update other dependent properties of the tfield
        old_size = self._size
        self._size = len(self.valuebytes)
        self._raw = self._raw[:self.slice.start * 2] + self.valuehex + \
                    self._raw[self.slice.stop * 2:]
        self.slice = slice(self.slice.start, self.slice.start + self.size)
        # Updating the slice of the rest of the tfields
        fields = self._layer.fieldnames()
        # Getting the next tfields next to the modified one
        fields = fields[fields.index(self._name) + 1:]
        # Updating the slice for each field
        for f in fields:
            sl = self._layer._fields[f].slice
            sz = self._size - old_size
            self._layer._fields[f].slice = slice(sl.start + sz, sl.stop + sz)
            self._layer._fields[f]._raw = self._raw

    def create_value(self, value):
        """Create a :obj:`Value` from an input value.

        Parameters
        ----------
        value: :obj:`str` or :obj:`bytes` or :obj:`int`
           Input parameter in any format.

        Returns
        -------
        :obj:`Value`
            Returns a :obj:`Value` with the representation of the input
            parameter.

        """
        if type(value) is int:
            value = Value(value.to_bytes(self._size, 'big'))
            value.to_int()
            self._ftype = value.type()
            return value
        elif type(value) is str:
            if self._ishex(value):
                value = Value(bytearray.fromhex(value))
                value.to_hex()
                self._ftype = value.type()
                return value
            value = Value(value.encode())
            value.to_str()
            self._ftype = value.type()
            return value
        elif type(value) is bytes or value is bytearray:
            value = Value(value)
            value.to_bytes()
            self._ftype = value.type()
            return value
        else:
            raise TypeError

    @property
    def slice(self):
        """:obj:`slice`: Slice that represents the position of the `TField`
        in the raw payload.

        The setter will encode de slice object into hexadecimal to be stored.
        """
        return eval(bytearray.fromhex(self._slice))

    @slice.setter
    def slice(self, value):
        if type(value) is not slice:
            raise TypeError
        self._slice = str(value).encode().hex()

    @property
    def raw(self):
        """:obj:`bytearray` : Package content in raw (bytes representation)."""
        return bytearray.fromhex(self._raw)

    def is_custom(self):
        """Returns True if the `TField` has been set as custom,
        False otherwise.

        Returns
        -------
        :obj:`bool`

        """
        return self._custom

    def set_custom(self):
        """Sets the :obj:`TField` as custom."""
        self._custom = True

    def unset_custom(self):
        """Unsets the :obj:`TField` as custom."""
        self._custom = False

    @property
    def valuehex(self):
        """str: Returns the value encoded in hexadecimal of the `TField`.

        The setter will instantiate a `Value` class.
        """
        return self._value.hex()

    @property
    def valuebytes(self):
        """:obj:`bytes` Returns the value encoded in bytes of the `TField`.

        The setter will instantiate a `Value` class.
        """
        return bytes(self._value)

    @property
    def size(self):
        """int: Returns the size of the `TField`."""
        return self._size

    @size.setter
    def size(self, value):
        self._size = value

    @property
    def type(self):
        """:obj:`tuple`: Returns the type of the `TField`."""
        return self._ftype

    @property
    def layer(self):
        """str: Returns the name of the parent `TLayer`."""
        return self._layer

    @layer.setter
    def layer(self, value):
        self._layer = value

    @staticmethod
    def _ishex(value):
        """Returns true if value is hex.

        Parameters
        ----------
        value: :obj:`str`
            A string that can be or not hex.

        """
        try:
            int(value, 16)
            return True
        except ValueError:
            return False

    def show(self):
        """Show a the properties of the `TField`."""
        print('\n', colored("---[ %s ]---" % self._name, 'cyan', attrs=['bold']), sep="")
        print('{0: <20}'.format("value"),"=", self.value, colored("(%s)" % self.frepr, 'white'))
        print('{0: <20}'.format("bytes"), "=", self.valuebytes)
        print('{0: <20}'.format("hex"), "=", self.valuehex)
        print('{0: <20}'.format("size"), "=", str(self.size))
        print('{0: <20}'.format("slice"), "=", "[%s, %s]" %
              (str(self.slice.start), str(self.slice.stop)))
        print('{0: <20}'.format("custom"), "=", str(self._custom))
        if self.type[0] is int:
            t = "int"
        elif self.type[0] is str:
            if self.type[1] == 'hex':
                t = "hex"
            else:
                t = "str"
        elif self.type[0] is bytes:
            t = "bytes"
        print('{0: <20}'.format("type"),"=", t, '\n')

    def dict(self):
        """Build a dictionary with all the elements of the `TField`.

        Returns
        -------
        :obj:`dict`
            Dictionary with all the attributes of the `TField`.

        """
        return OrderedDict([("name", self._name),
                            ("value", self._value.hex()),
                            ("type", (str(self._ftype[0]), self._ftype[1])),
                            ("size", self._size),
                            ("slice", self._slice),
                            ("frepr", self._frepr),
                            ("custom", self._custom)])
